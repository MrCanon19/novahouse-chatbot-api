import os
from typing import Any, Dict, Optional

from openai import OpenAI
from sqlalchemy.orm import Session

from src.chatbot.pipelines.chat_pipeline import ChatPipeline
from src.chatbot.strategies.conversation_initialization_strategy import (
    ConversationInitializationStrategy,
)
from src.chatbot.strategies.extraction_strategy import ContextExtractionStrategy
from src.chatbot.strategies.faq_strategy import FaqStrategy
from src.chatbot.strategies.gpt_strategy import GptStrategy
from src.chatbot.strategies.lead_creation_strategy import LeadCreationStrategy
from src.chatbot.strategies.persistence_strategy import PersistenceStrategy
from src.integrations.monday_client import MondayClient
from src.services.email_service import EmailService  # Assuming EmailService exists
from src.services.faq_service import FaqService


class ChatService:
    """
    Orchestrates the entire chatbot logic using a pipeline of strategies.
    This class replaces the monolithic process_chat_message function.
    """

    def __init__(self, db_session: Session):
        self.db_session = db_session

        # Initialize external clients and services
        self.openai_client = self._initialize_openai_client()
        self.monday_client_instance = MondayClient(api_key=os.getenv("MONDAY_API_KEY", ""))
        self.email_service = EmailService()  # Assuming EmailService can be initialized directly
        self.admin_email = os.getenv("ADMIN_EMAIL", "admin@novahouse.pl")
        self.faq_service = FaqService()

        # Initialize strategies
        self.conversation_init_strategy = ConversationInitializationStrategy(
            db_session=self.db_session
        )
        self.context_extraction_strategy = ContextExtractionStrategy()
        self.faq_strategy = FaqStrategy(faq_service=self.faq_service)
        self.gpt_strategy = GptStrategy(
            openai_client=self.openai_client,
            gpt_model=os.getenv("GPT_MODEL", "gpt-4o-mini"),
            db_session=self.db_session,
        )
        self.lead_creation_strategy = LeadCreationStrategy(
            db_session=self.db_session,
            monday_client=self.monday_client_instance,
            email_service=self.email_service,
            admin_email=self.admin_email,
            monday_api_key=os.getenv("MONDAY_API_KEY", ""),
        )
        self.persistence_strategy = PersistenceStrategy(db_session=self.db_session)

        # Assemble the pipeline
        self.pipeline = ChatPipeline(
            strategies=[
                self.conversation_init_strategy,
                self.context_extraction_strategy,
                self.faq_strategy,
                self.gpt_strategy,  # GPT as fallback if no FAQ match
                self.lead_creation_strategy,  # Processes lead creation and confirmation
                self.persistence_strategy,  # Always last to save state
            ]
        )

    def _initialize_openai_client(self) -> Optional[OpenAI]:
        """Lazy load OpenAI client based on environment variables."""
        gpt_enabled = os.getenv("GPT_FALLBACK_ENABLED", "true").lower() == "true"
        openai_api_key = os.getenv("OPENAI_API_KEY", "")

        if not gpt_enabled or not openai_api_key or openai_api_key.lower().startswith("test_"):
            logging.warning("⚠️  GPT disabled or API key missing/placeholder – OpenAI client not initialized.")
            return None

        try:
            from openai import OpenAI

            client = OpenAI(api_key=openai_api_key)
            logging.info(f"✅ OpenAI client initialized with model: {os.getenv('GPT_MODEL', 'gpt-4o-mini')}")
            return client
        except ImportError:
            logging.warning("⚠️  openai package not installed - GPT disabled.")
            return None
        except Exception as e:
            logging.error(f"❌ Error initializing OpenAI client: {e}", exc_info=True)
            return None

    def process_message(self, user_message: str, session_id: str) -> Dict[str, Any]:
        """
        Processes a user message through the defined chatbot pipeline.

        Args:
            user_message: The message received from the user.
            session_id: The unique identifier for the user's session.

        Returns:
            A dictionary containing the bot's response, session_id, and conversation_id.
        """
        initial_context = {
            "user_message": user_message,
            "session_id": session_id,
            "bot_response": None,  # Initialize bot_response
        }

        try:
            final_context = self.pipeline.process(initial_context)

            # Ensure a bot_response is always present
            if not final_context.get("bot_response"):
                print(
                    "[WARNING] No bot_response generated by any strategy. Falling back to generic."
                )
                final_context["bot_response"] = (
                    "Przepraszam, nie rozumiem. Czy możesz przeformułować pytanie?"
                )

            return {
                "response": final_context["bot_response"],
                "session_id": final_context["session_id"],
                "conversation_id": (
                    final_context["conversation"].id if final_context.get("conversation") else None
                ),
            }
        except Exception as e:
            self.db_session.rollback()  # Ensure rollback on any pipeline error
            print(f"❌ Error processing message through pipeline: {e}")
            return {
                "response": "Przepraszam, wystąpił wewnętrzny błąd. Spróbuj ponownie.",
                "session_id": session_id,
                "conversation_id": None,
                "error": str(e),
            }


# This global instance will be replaced by dependency injection in the Flask app.
# For now, it provides compatibility with the old route structure.
# chat_service = ChatService(db_session=None) # db_session needs to be passed correctly in Flask app.
